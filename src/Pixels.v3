enum PixelType(numPixels: int) {
    RGB(3),
    RGBA(4),
    BGR(3),
    BGRA(4),
    GRAY(1)
}

layout RGB {
       +0	red:	byte;	// red intensity 0...255
       +1	green:	byte;	// green intensity 0...255
       +2	blue:	byte;	// blue intensity 0...255
       =3;			// total size = 3 bytes
}

layout RGBA {
       +0	red:	byte;	// red intensity 0...255
       +1	green:	byte;	// green intensity 0...255
       +2	blue:	byte;	// blue intensity 0...255
       +3	alpha:	byte;	// alpha channel (transparency)
       =4;			// total size = 4 bytes
}

layout BGR {
    +0  blue: byte;   // blue intensity 0...255
    +1	green:	byte;	// green intensity 0...255
    +2  red:	byte;	// red intensity 0...255
    =3;         // total size = 3 bytes
}

layout BGRA {
    +0  blue: byte;   // blue intensity 0...255
    +1	green:	byte;	// green intensity 0...255
    +2  red:	byte;	// red intensity 0...255
    +3	alpha:	byte;	// alpha channel (transparency)
    =4;         // total size = 3 bytes
}

layout GRAY {
    +0 gray: byte;   // gray intensity 0...255
    =1;     // total size = 1 byte
}

class PixelData {
    private var data: Array<byte>;
    private def width: u32;
    private def height: u32;
    private var pixelType: PixelType;
    private var channels: int;

    new(width: u32, height: u32) {}

    def start() -> Pointer { return Pointer.atContents(data); }
    def size() -> u32 { return u32.!(data.length); }
    def getPixelType() -> PixelType { return pixelType; }
    def getWidth() -> u32 { return width; }
    def getHeight() -> u32 { return height; }
    def getChannels() -> int { return channels; }
}

class PixelDataRGB extends PixelData {
    new(width: u32, height: u32) super(width, height) {
        pixelType = PixelType.RGB;
        channels = pixelType.numPixels;
        data = Array<byte>.new(int.!(width) * int.!(height) * channels);
    }
    def [x: int, y: int] -> Ref<RGB> { return Ref<RGB>.at(data, x * y); }
}

class PixelDataRGBA extends PixelData {
    new(width: u32, height: u32) super(width, height) {
        pixelType = PixelType.RGBA;
        channels = pixelType.numPixels;
        data = Array<byte>.new(int.!(width) * int.!(height) * channels);
    }
    def [x: int, y: int] -> Ref<RGBA> { return Ref<RGBA>.at(data, x * y); }
}

class PixelDataBGR extends PixelData {
    new(width: u32, height: u32) super(width, height) {
        pixelType = PixelType.BGR;
        channels = pixelType.numPixels;
        data = Array<byte>.new(int.!(width) * int.!(height) * channels);
    }
    def [x: int, y: int] -> Ref<BGR> { return Ref<BGR>.at(data, x * y); }
}

class PixelDataBGRA extends PixelData {
    new(width: u32, height: u32) super(width, height) {
        pixelType = PixelType.BGRA;
        channels = pixelType.numPixels;
        data = Array<byte>.new(int.!(width) * int.!(height) * channels);
    }
    def [x: int, y: int] -> Ref<BGRA> { return Ref<BGRA>.at(data, x * y); }
}

class PixelDataGRAY extends PixelData {
    new(width: u32, height: u32) super(width, height) {
        pixelType = PixelType.GRAY;
        channels = pixelType.numPixels;
        data = Array<byte>.new(int.!(width) * int.!(height) * channels);
    }
    def [x: int, y: int] -> Ref<GRAY> { return Ref<GRAY>.at(data, x * y); }
    def at(i: int)  -> Ref<GRAY> { return Ref<GRAY>.at(data, i); }
    def to_Array() -> Array<byte> {
        /*var out = Array<byte>.new(int.!(this.size()));
        for(i < this.size()) {
           out[i] = Ref<GRAY>.at(data, int.!(i)).gray;
        }*/
    //return out;
    return data;
    }
}